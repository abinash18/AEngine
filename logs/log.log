
-------------------------------------December 18, 2019 8:36 AM-------------------------------------

[December 18, 2019 8:36 AM] [net.abi.abisEngine.core.CoreEngine] INFO: Starting Engine.
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.windowManagement.GLFWWindowManager] ERROR: Monitor Provided Is NULL, Defaulting To Primary Monitor.
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.sceneManagement.SceneManager] DEBUG: Setting Scene: EngineSplash
[December 18, 2019 8:36 AM] [AssetManager] DEBUG: Loader set: ModelScene -> ModelSceneLoader
[December 18, 2019 8:36 AM] [AssetManager] DEBUG: Loader set: ModelScene -> ModelSceneLoader
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Successfully Attached Shader: 1 Log: 

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] DEBUG: Shader Text For 'Vertex Shader': 'forward-directional'
#version 120
attribute vec3 position;
attribute vec2 texCoord;
attribute vec3 normal;
attribute vec3 tangent;
varying vec2 texCoord0;
varying vec3 normal0;
varying vec3 worldPosition0;
varying mat3 tbnMatrix;
uniform mat4 T_model;
uniform mat4 T_MVP;
void main() {
gl_Position = T_MVP * vec4(position, 1.0);
texCoord0 =  texCoord;
normal0 = (T_model * vec4(normal, 0.0)).xyz;
worldPosition0 = (T_model * vec4(position, 1.0)).xyz;
vec3 n = normalize((T_model * vec4(normal, 0.0)).xyz);
vec3 t = normalize((T_model * vec4(tangent, 0.0)).xyz);
t = normalize(t - dot(t, n) * n);
vec3 biTangent = cross(t, n);
tbnMatrix = mat3(t, biTangent, n);
}

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Successfully Attached Shader: 1 Log: 

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] DEBUG: Shader Text For 'Fragment Shader': 'forward-directional'
#version 120
varying vec2 texCoord0;
varying vec3 normal0;
varying vec3 worldPosition0;
varying mat3 tbnMatrix;
uniform sampler2D diffuse;
uniform sampler2D normal_map;
uniform vec3 C_eyePos;
uniform float specularIntensity;
uniform float specularPower;
uniform int normal_mapping_enabled;
struct BaseLight {
vec3 color;
float intensity;
};
struct DirectionalLight {
BaseLight base;
vec3 direction;
};
struct Attenuation {
float constant;
float linear;
float exponent;
};
struct PointLight {
BaseLight base;
Attenuation atten;
vec3 position;
float range;
};
struct SpotLight {
PointLight pointLight;
vec3 direction;
float cutoff;
};
vec4 calcLight(BaseLight base, vec3 direction, vec3 normal, vec3 worldPosition) {
float diffuseFactor = dot(normal, -direction);
vec4 diffuseColor = vec4(0, 0, 0, 0);
vec4 specularColor = vec4(0, 0, 0, 0);
if (diffuseFactor > 0) {
diffuseColor = vec4(base.color, 1.0) * base.intensity * diffuseFactor;
vec3 directionToEye = normalize(C_eyePos - worldPosition);
vec3 reflectDirection = normalize(reflect(direction, normal));
float specularFactor = dot(directionToEye, reflectDirection);
specularFactor = pow(specularFactor, specularPower);
if(specularFactor > 0){
specularColor = vec4(base.color, 1.0) * specularIntensity * specularFactor;
}
}
return diffuseColor + specularColor;
}
vec4 calcDirectionalLight(DirectionalLight directionalLight, vec3 normal, vec3 worldPosition) {
return (calcLight(directionalLight.base, -directionalLight.direction, normal, worldPosition));
}
vec4 calcPointLight(PointLight pointLight, vec3 normal, vec3 worldPosition){
vec3 lightDirection = worldPosition - pointLight.position;
float distanceToPoint = length(lightDirection);
if (distanceToPoint > pointLight.range) {
return vec4(0, 0, 0, 0);
}
lightDirection = normalize(lightDirection);
vec4 color = calcLight(pointLight.base, lightDirection, normal, worldPosition);
float attenuation = pointLight.atten.constant + pointLight.atten.linear * distanceToPoint +
pointLight.atten.exponent * distanceToPoint * distanceToPoint + 0.0001;
return color / attenuation;
}
vec4 calcSpotLight(SpotLight spotLight, vec3 normal, vec3 worldPosition)  {
vec3 lightDirection = normalize(worldPosition - spotLight.pointLight.position);
float spotFactor = dot(lightDirection, spotLight.direction);
vec4 color = vec4(0, 0, 0, 0);
if (spotFactor > spotLight.cutoff) {
color = calcPointLight(spotLight.pointLight, normal, worldPosition) *
(1.0 - (1.0 - spotFactor) / (1.0 - spotLight.cutoff));
}
return color;
}
vec3 getNormalFromMap(sampler2D normal_map, vec2 texCoord, mat3 tbnMatrix)  {
vec3 normal = tbnMatrix * (255.0/128.0 * texture2D(normal_map, texCoord0.xy).xyz - 1);
return normal;
}
uniform DirectionalLight R_directionalLight;
vec4 calcLighting(vec3 normal, vec3 worldPos) {
return calcDirectionalLight(R_directionalLight, normal, worldPos);
}
void main() {
vec3 normal;
if (normal_mapping_enabled == 0) {
normal = tbnMatrix * (255.0/128.0 * texture2D(normal_map, texCoord0.xy).xyz - 1);
} else {
normal = normalize(normal0);
}
gl_FragColor = texture2D(diffuse, texCoord0.xy) * calcLighting(normal, worldPosition0);
}

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'T_model' At Location: 5
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'T_MVP' At Location: 4
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'diffuse' At Location: 9
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'normal_map' At Location: 10
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'C_eyePos' At Location: 0
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'specularIntensity' At Location: 7
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'specularPower' At Location: 8
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'normal_mapping_enabled' At Location: 6
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_directionalLight.base.color' At Location: 1
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_directionalLight.base.intensity' At Location: 2
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_directionalLight.direction' At Location: 3
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Successfully Attached Shader: 4 Log: 

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] DEBUG: Shader Text For 'Vertex Shader': 'forward-point'
#version 120
attribute vec3 position;
attribute vec2 texCoord;
attribute vec3 normal;
attribute vec3 tangent;
varying vec2 texCoord0;
varying vec3 normal0;
varying vec3 worldPosition0;
varying mat3 tbnMatrix;
uniform mat4 T_model;
uniform mat4 T_MVP;
void main() {
gl_Position = T_MVP * vec4(position, 1.0);
texCoord0 =  texCoord;
normal0 = (T_model * vec4(normal, 0.0)).xyz;
worldPosition0 = (T_model * vec4(position, 1.0)).xyz;
vec3 n = normalize((T_model * vec4(normal, 0.0)).xyz);
vec3 t = normalize((T_model * vec4(tangent, 0.0)).xyz);
t = normalize(t - dot(t, n) * n);
vec3 biTangent = cross(t, n);
tbnMatrix = mat3(t, biTangent, n);
}

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Successfully Attached Shader: 4 Log: 

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] DEBUG: Shader Text For 'Fragment Shader': 'forward-point'
#version 120
varying vec2 texCoord0;
varying vec3 normal0;
varying vec3 worldPosition0;
varying mat3 tbnMatrix;
uniform sampler2D diffuse;
uniform sampler2D normal_map;
uniform vec3 C_eyePos;
uniform float specularIntensity;
uniform float specularPower;
uniform int normal_mapping_enabled;
struct BaseLight {
vec3 color;
float intensity;
};
struct DirectionalLight {
BaseLight base;
vec3 direction;
};
struct Attenuation {
float constant;
float linear;
float exponent;
};
struct PointLight {
BaseLight base;
Attenuation atten;
vec3 position;
float range;
};
struct SpotLight {
PointLight pointLight;
vec3 direction;
float cutoff;
};
vec4 calcLight(BaseLight base, vec3 direction, vec3 normal, vec3 worldPosition) {
float diffuseFactor = dot(normal, -direction);
vec4 diffuseColor = vec4(0, 0, 0, 0);
vec4 specularColor = vec4(0, 0, 0, 0);
if (diffuseFactor > 0) {
diffuseColor = vec4(base.color, 1.0) * base.intensity * diffuseFactor;
vec3 directionToEye = normalize(C_eyePos - worldPosition);
vec3 reflectDirection = normalize(reflect(direction, normal));
float specularFactor = dot(directionToEye, reflectDirection);
specularFactor = pow(specularFactor, specularPower);
if(specularFactor > 0){
specularColor = vec4(base.color, 1.0) * specularIntensity * specularFactor;
}
}
return diffuseColor + specularColor;
}
vec4 calcDirectionalLight(DirectionalLight directionalLight, vec3 normal, vec3 worldPosition) {
return (calcLight(directionalLight.base, -directionalLight.direction, normal, worldPosition));
}
vec4 calcPointLight(PointLight pointLight, vec3 normal, vec3 worldPosition){
vec3 lightDirection = worldPosition - pointLight.position;
float distanceToPoint = length(lightDirection);
if (distanceToPoint > pointLight.range) {
return vec4(0, 0, 0, 0);
}
lightDirection = normalize(lightDirection);
vec4 color = calcLight(pointLight.base, lightDirection, normal, worldPosition);
float attenuation = pointLight.atten.constant + pointLight.atten.linear * distanceToPoint +
pointLight.atten.exponent * distanceToPoint * distanceToPoint + 0.0001;
return color / attenuation;
}
vec4 calcSpotLight(SpotLight spotLight, vec3 normal, vec3 worldPosition)  {
vec3 lightDirection = normalize(worldPosition - spotLight.pointLight.position);
float spotFactor = dot(lightDirection, spotLight.direction);
vec4 color = vec4(0, 0, 0, 0);
if (spotFactor > spotLight.cutoff) {
color = calcPointLight(spotLight.pointLight, normal, worldPosition) *
(1.0 - (1.0 - spotFactor) / (1.0 - spotLight.cutoff));
}
return color;
}
vec3 getNormalFromMap(sampler2D normal_map, vec2 texCoord, mat3 tbnMatrix)  {
vec3 normal = tbnMatrix * (255.0/128.0 * texture2D(normal_map, texCoord0.xy).xyz - 1);
return normal;
}
uniform PointLight R_pointLight;
vec4 calcLighting(vec3 normal, vec3 worldPos) {
return calcPointLight(R_pointLight, normal, worldPos);
}
void main() {
vec3 normal;
if (normal_mapping_enabled == 0) {
normal = tbnMatrix * (255.0/128.0 * texture2D(normal_map, texCoord0.xy).xyz - 1);
} else {
normal = normalize(normal0);
}
gl_FragColor = texture2D(diffuse, texCoord0.xy) * calcLighting(normal, worldPosition0);
}

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'T_model' At Location: 9
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'T_MVP' At Location: 8
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'diffuse' At Location: 13
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'normal_map' At Location: 14
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'C_eyePos' At Location: 0
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'specularIntensity' At Location: 11
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'specularPower' At Location: 12
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'normal_mapping_enabled' At Location: 10
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_pointLight.base.color' At Location: 1
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_pointLight.base.intensity' At Location: 2
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_pointLight.atten.constant' At Location: 3
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_pointLight.atten.linear' At Location: 4
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_pointLight.atten.exponent' At Location: 5
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_pointLight.position' At Location: 6
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_pointLight.range' At Location: 7
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Successfully Attached Shader: 7 Log: 

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] DEBUG: Shader Text For 'Vertex Shader': 'forward-spot'
#version 120
attribute vec3 position;
attribute vec2 texCoord;
attribute vec3 normal;
attribute vec3 tangent;
varying vec2 texCoord0;
varying vec3 normal0;
varying vec3 worldPosition0;
varying mat3 tbnMatrix;
uniform mat4 T_model;
uniform mat4 T_MVP;
void main() {
gl_Position = T_MVP * vec4(position, 1.0);
texCoord0 =  texCoord;
normal0 = (T_model * vec4(normal, 0.0)).xyz;
worldPosition0 = (T_model * vec4(position, 1.0)).xyz;
vec3 n = normalize((T_model * vec4(normal, 0.0)).xyz);
vec3 t = normalize((T_model * vec4(tangent, 0.0)).xyz);
t = normalize(t - dot(t, n) * n);
vec3 biTangent = cross(t, n);
tbnMatrix = mat3(t, biTangent, n);
}

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Successfully Attached Shader: 7 Log: 

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] DEBUG: Shader Text For 'Fragment Shader': 'forward-spot'
#version 120
varying vec2 texCoord0;
varying vec3 normal0;
varying vec3 worldPosition0;
varying mat3 tbnMatrix;
uniform sampler2D diffuse;
uniform sampler2D normal_map;
uniform vec3 C_eyePos;
uniform float specularIntensity;
uniform float specularPower;
uniform int normal_mapping_enabled;
struct BaseLight {
vec3 color;
float intensity;
};
struct DirectionalLight {
BaseLight base;
vec3 direction;
};
struct Attenuation {
float constant;
float linear;
float exponent;
};
struct PointLight {
BaseLight base;
Attenuation atten;
vec3 position;
float range;
};
struct SpotLight {
PointLight pointLight;
vec3 direction;
float cutoff;
};
vec4 calcLight(BaseLight base, vec3 direction, vec3 normal, vec3 worldPosition) {
float diffuseFactor = dot(normal, -direction);
vec4 diffuseColor = vec4(0, 0, 0, 0);
vec4 specularColor = vec4(0, 0, 0, 0);
if (diffuseFactor > 0) {
diffuseColor = vec4(base.color, 1.0) * base.intensity * diffuseFactor;
vec3 directionToEye = normalize(C_eyePos - worldPosition);
vec3 reflectDirection = normalize(reflect(direction, normal));
float specularFactor = dot(directionToEye, reflectDirection);
specularFactor = pow(specularFactor, specularPower);
if(specularFactor > 0){
specularColor = vec4(base.color, 1.0) * specularIntensity * specularFactor;
}
}
return diffuseColor + specularColor;
}
vec4 calcDirectionalLight(DirectionalLight directionalLight, vec3 normal, vec3 worldPosition) {
return (calcLight(directionalLight.base, -directionalLight.direction, normal, worldPosition));
}
vec4 calcPointLight(PointLight pointLight, vec3 normal, vec3 worldPosition){
vec3 lightDirection = worldPosition - pointLight.position;
float distanceToPoint = length(lightDirection);
if (distanceToPoint > pointLight.range) {
return vec4(0, 0, 0, 0);
}
lightDirection = normalize(lightDirection);
vec4 color = calcLight(pointLight.base, lightDirection, normal, worldPosition);
float attenuation = pointLight.atten.constant + pointLight.atten.linear * distanceToPoint +
pointLight.atten.exponent * distanceToPoint * distanceToPoint + 0.0001;
return color / attenuation;
}
vec4 calcSpotLight(SpotLight spotLight, vec3 normal, vec3 worldPosition)  {
vec3 lightDirection = normalize(worldPosition - spotLight.pointLight.position);
float spotFactor = dot(lightDirection, spotLight.direction);
vec4 color = vec4(0, 0, 0, 0);
if (spotFactor > spotLight.cutoff) {
color = calcPointLight(spotLight.pointLight, normal, worldPosition) *
(1.0 - (1.0 - spotFactor) / (1.0 - spotLight.cutoff));
}
return color;
}
vec3 getNormalFromMap(sampler2D normal_map, vec2 texCoord, mat3 tbnMatrix)  {
vec3 normal = tbnMatrix * (255.0/128.0 * texture2D(normal_map, texCoord0.xy).xyz - 1);
return normal;
}
uniform SpotLight R_spotLight;
vec4 calcLighting(vec3 normal, vec3 worldPos) {
return calcSpotLight(R_spotLight, normal, worldPos);
}
void main() {
vec3 normal;
if (normal_mapping_enabled == 0) {
normal = tbnMatrix * (255.0/128.0 * texture2D(normal_map, texCoord0.xy).xyz - 1);
} else {
normal = normalize(normal0);
}
gl_FragColor = texture2D(diffuse, texCoord0.xy) * calcLighting(normal, worldPosition0);
}

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'T_model' At Location: 11
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'T_MVP' At Location: 10
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'diffuse' At Location: 15
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'normal_map' At Location: 16
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'C_eyePos' At Location: 0
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'specularIntensity' At Location: 13
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'specularPower' At Location: 14
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'normal_mapping_enabled' At Location: 12
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_spotLight.pointLight.base.color' At Location: 1
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_spotLight.pointLight.base.intensity' At Location: 2
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_spotLight.pointLight.atten.constant' At Location: 3
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_spotLight.pointLight.atten.linear' At Location: 4
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_spotLight.pointLight.atten.exponent' At Location: 5
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_spotLight.pointLight.position' At Location: 6
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_spotLight.pointLight.range' At Location: 7
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_spotLight.direction' At Location: 8
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_spotLight.cutoff' At Location: 9
[December 18, 2019 8:36 AM] [AssetManager] DEBUG: Queued: net.abi.abisEngine.rendering.asset.AssetClassifier@57fffcd7
[December 18, 2019 8:36 AM] [AssetManager] DEBUG: Queued: net.abi.abisEngine.rendering.asset.AssetClassifier@31ef45e3
[December 18, 2019 8:36 AM] [AssetManager] DEBUG: Queued: net.abi.abisEngine.rendering.asset.AssetClassifier@598067a5
[December 18, 2019 8:36 AM] [AssetManager] DEBUG: Queued: net.abi.abisEngine.rendering.asset.AssetClassifier@3c0ecd4b
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.sceneManagement.SceneManager] DEBUG: Current Scene: Scene [root=net.abi.abisEngine.core.Entity@14bf9759, id=4d665001-f692-47d0-baf3-e388216f282d, name=EngineSplash]
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.sceneManagement.SceneManager] DEBUG: Current Scene: Scene [root=net.abi.abisEngine.core.Entity@14bf9759, id=4d665001-f692-47d0-baf3-e388216f282d, name=EngineSplash]
[December 18, 2019 8:36 AM] [AssetManager] DEBUG: Loader set: ModelScene -> ModelSceneLoader
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Successfully Attached Shader: 10 Log: 

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] DEBUG: Shader Text For 'Vertex Shader': 'forward-ambient'
#version 120
attribute vec3 position;
attribute vec2 texCoord;
varying vec2 texCoord0;
uniform mat4 T_MVP;
void main() {
gl_Position = T_MVP * vec4(position, 1.0);
texCoord0 = texCoord;
}

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Successfully Attached Shader: 10 Log: 

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] DEBUG: Shader Text For 'Fragment Shader': 'forward-ambient'
#version 120
varying vec2 texCoord0;
uniform vec3 R_ambient;
uniform sampler2D diffuse;
void main() {
gl_FragColor = texture2D(diffuse, texCoord0.xy) * vec4(R_ambient, 1.0);
}

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'T_MVP' At Location: 1
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'R_ambient' At Location: 0
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'diffuse' At Location: 2
[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Successfully Attached Shader: 13 Log: 

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] DEBUG: Shader Text For 'Vertex Shader': 'visualizers/depthVisualizer'
#version 330 core
attribute vec3 position;
uniform mat4 T_MVP;
void main() {
gl_Position = T_MVP * vec4(position, 1.0);
}

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Successfully Attached Shader: 13 Log: 

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] DEBUG: Shader Text For 'Fragment Shader': 'visualizers/depthVisualizer'
#version 330 core
out vec4 FragColor;
float near = 0.1;
float far  = 1000.0;
float LinearizeDepth(float depth) {
float z = depth * 2.0 - 1.0;
return (2.0 * near * far) / (far + near - z * (far - near));
}
void main()	{
float depth = LinearizeDepth(gl_FragCoord.z) / far;
FragColor = vec4(vec3(depth), 1.0);
}

[December 18, 2019 8:36 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'T_MVP' At Location: 0
[December 18, 2019 8:36 AM] [AssetManager] INFO: Loading: net.abi.abisEngine.rendering.asset.AssetClassifier@57fffcd7
[December 18, 2019 8:36 AM] [AssetManager] INFO: Loading: net.abi.abisEngine.rendering.asset.AssetClassifier@31ef45e3
[December 18, 2019 8:36 AM] [AssetManager] INFO: Loading: net.abi.abisEngine.rendering.asset.AssetClassifier@598067a5
[December 18, 2019 8:37 AM] [AssetManager] DEBUG: Already loaded: net.abi.abisEngine.rendering.asset.AssetClassifier@3c0ecd4b
[December 18, 2019 8:37 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Successfully Attached Shader: 16 Log: 

[December 18, 2019 8:37 AM] [net.abi.abisEngine.rendering.shaders.Shader] DEBUG: Shader Text For 'Vertex Shader': 'visualizers/wireframe'
#version 330 core
attribute vec3 position;
uniform mat4 T_MVP;
void main() {
gl_Position = T_MVP * vec4(position, 1.0);
}

[December 18, 2019 8:37 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Successfully Attached Shader: 16 Log: 

[December 18, 2019 8:37 AM] [net.abi.abisEngine.rendering.shaders.Shader] DEBUG: Shader Text For 'Fragment Shader': 'visualizers/wireframe'
#version 330 core
out vec4 FragColor;
void main()	{
FragColor = vec4(vec3(0,1,0), 1.0);
}

[December 18, 2019 8:37 AM] [net.abi.abisEngine.rendering.shaders.Shader] FINE: Uniform 'T_MVP' At Location: 0
[December 18, 2019 8:37 AM] [net.abi.abisEngine.rendering.windowManagement.GLFWWindowManager] DEBUG: Monitor Provided Is NULL, Defaulting To Primary Monitor.
